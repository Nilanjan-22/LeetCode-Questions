class Solution {
public:
    class DSU{
        
    public:
        vector<int> parent, size;
        DSU(int n){
            size.resize(n,1);
            parent.resize(n);
            for(int i=0;i<n;i++)parent[i]=i;
        }

        int find_ulp(int node){
            if(parent[node]==node)return node;
            return parent[node]=find_ulp(parent[node]);
        }

        void connect(int n1 , int n2){
            int u1=find_ulp(n1),u2=find_ulp(n2);

            if(u1==u2)return;
            if(size[u1]>size[u2]){
                size[u1]+=size[u2];
                parent[u2]=u1;
            }
            else{
                size[u2]+=size[u1];
                parent[u1]=u2;
            }
        }
    };
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n=graph.size();
        DSU ds(n);
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(graph[i][j]==1)ds.connect(i,j);
            }
        }

        map<int, vector<int>> mp; //ultimate parent-> cnt,size,firstapp
        int mini=n;
        for(int i=0;i<initial.size();i++){
            mini=min(mini,initial[i]);
            int u=ds.find_ulp(initial[i]);
            cout<<u<<" "<<ds.size[u]<<endl;
            if(mp.find(u)==mp.end())mp[u]={1,ds.size[u],initial[i]};
            else mp[u][0]++;
        }

        int ans=mini, ms=-1;
        for(auto it: mp){
            if(it.second[0]>1)continue;
            else{
                if(it.second[1]>ms){
                    ms=it.second[1];
                    ans=it.second[2];
                }
                else if(it.second[1]==ms){
                    if(it.second[2]<ans)ans=it.second[2];
                }
            }
        }
        return ans;
    }
};